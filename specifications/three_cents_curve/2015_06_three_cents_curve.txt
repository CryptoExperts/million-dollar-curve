# Description

This file specifies the "Design" of the Three Cent Curve cryptosystem, in the sense of [1].

See https://cryptoexperts.github.io/million-dollar-curve

# Authors

CryptoExperts


# Date

21st of June, 2015


# Contact

curves@cryptoexperts.com


# The Cryptosystem

An elliptic curve in Edwards form E :

x^2 + y^2 = 1 + d x^2 y^2

over a prime field Fp, together with a point (x,y) on this curve that shall generate a large subgroup.


# The Security Criteria

(1) p must be a 256 bit prime.

(2) The parameter d of the Edwards curve must not be a square in Fp.

(3) The number of point #E(Fp) of must be of the form 4q, where q is prime.

(4) The base point (x,y) must generate a subgroup of order q.

(5) The embedding degree m of the curve must verify m > (q-1)/100.

(6) The CM field discriminant D of the curve must verify |D| \ge 2^{100}.

(7) The curve must be twist secure, i.e., the constraints (3) and (5) must also hold for the twist of E.


# How to turn a seed into specific parameters for the Cryptosystem, such that all the security criteria are met

The source code we provide is made of 3 scripts, that shall be executed sequentially (the source code of which is
provided at the bottom of this file):

- 02_generate_bbs_parameters.py

- 03_generate_prime_field_using_bbs.py

- 04_generate_curve_using_bbs.py

In the remaining of this section, we explain how to use these script to generate a cryptosystem meeting all the above
security criteria. This cryptosystem should NOT be used for cryptographic purposes, since we give no explanation on how
the seed we provide was generated. It is only meant to be an illustrative example.

The first script takes as an input a JSON file specifying the seed and its upper-bound (it is assumed
that the lower-bound for the seed is 0). The variable names are "seed" and "seed_upper_bound" respectively, and the
values will be treated as integers. The seed upper bound will allow the script to evaluate the quantity of entropy
provided by the seed, assuming that it was drawn uniformly at random.

-----BEGIN EXAMPLE INPUT JSON FILE TO 02_generate_bbs_parameters.py (in_02.json)-----
{"seed": 627715638141303109846528875780167323583941051076490219409639328204706553111265421102247984034239331066135888926954026378657535528751419894404446260723816432542290056397088102713076246983319330809633992468275718326157284699197163150817536747458820090772450222457548688125728890746138449343029740141312570904468919846933995881844039092526360828910303731392631968129907520600086044952209320990176025187211259442429496423327597191485689153704187804294105210256324505147741933610466067462578269305315708337228513355589489602298770727369518326162434523860003740820310306379771396820219016253808416089122562493966703319977986791502350602892782062378465434455849920647358799991037187775738706018856018144124579195261580408570448296559426521245539875116423514877987547820633707449785661563652127916687104562978307143584897368372766075640423499969981306671135319032333289330834261751390257473072014453816595828028042486158234177562188905805142171702437123550821507427848182168524092251358441619129549726441247608847453239310047878368965670285758255380617538120537392221016814840297445253966944279986805272009720688203989327250518927558647206791359474716137666481026115183505448916659902904054689800447794899890470940920101566632501001086217162217118182554334906000177491094871426512304415409464573495065244170212767173275375191416534657827409952194582763493629391458336410576826830366521411244516130645217180476371009150191389339306445603745243951146449588908195787551006279946670309947039417555864477032583123039723400040125518071854077025296889527303669727804348558134823852505302144230529217119354711630349644168549205044957305269803884257168802695333159630748637886281482209930654882982764494700321022095668015950970499715257177165184820581786356754690049608892552854742102543733513628195943956428791357498255380746095758310270601551317602097350934284407622544523092524689876438775378511503742284666760598133954675332101521896857528420235456118036360876645304972886539083769842336922537546249720123891618148823331523657465004511270083281295460383989935985563223936284716821127842579312636049687730058159816117030915553649512513317348580538663242058756989188796585203872259670505934249442056979917959509037970254013482682282170272567503111970697412137186316711234848578478076316472027534088425894065270499333786706015819617660766775014900907318245653602756027561669027295383741539740557100723841882000434463770620631558553403744654633816408629363856494330175020610081703701,
 "seed_upper_bound": 1090748135619415929462984244733782862448264161996232692431832786189721331849119295216264234525201987223957291796157025273109870820177184063610979765077554799078906298842192989538609825228048205159696851613591638196771886542609324560121290553901886301017900252535799917200010079600026535836800905297805880952350501630195475653911005312364560014847426035293551245843928918752768696279344088055617515694349945406677825140814900616105920256438504578013326493565836047242407382442812245131517757519164899226365743722432277368075027627883045206501792761700945699168497257879683851737049996900961120515655050115561271491492515342105748966629547032786321505730828430221664970324396138635251626409516168005427623435996308921691446181187406395310665404885739434832877428167407495370993511868756359970390117021823616749458620969857006263612082706715408157066575137281027022310927564910276759160520878304632411049364568754920967322982459184763427383790272448438018526977764941072715611580434690827459339991961414242741410599117426060556483763756314527611362658628383368621157993638020878537675545336789915694234433955666315070087213535470255670312004130725495834508357439653828936077080978550578912967907352780054935621561090795845172954115972927479877527738560008204118558930004777748727761853813510493840581861598652211605960308356405941821189714037868726219481498727603653616298856174822413033485438785324024751419417183012281078209729303537372804574372095228703622776363945290869806258422355148507571039619387449629866808188769662815778153079393179093143648340761738581819563002994422790754955061288818308430079648693232179158765918035565216157115402992120276155607873107937477466841528362987708699450152031231862594203085693838944657061346236704234026821102958954951197087076546186622796294536451620756509351018906023773821539532776208676978589731966330308893304665169436185078350641568336944530051437491311298834367265238595404904273455928723949525227184617404367854754610474377019768025576605881038077270707717942221977090385438585844095492116099852538903974655703943973086090930596963360767529964938414598185705963754561497355827813623833288906309004288017321424808663962671333528009232758350873059614118723781422101460198615747386855096896089189180441339558524822867541113212638793675567650340362970031930023397828465318547238244232028015189689660418822976000815437610652254270163595650875433851147123214227266605403581781469090806576468950587661997186505665475715792896,
 "approx_seed_entropy": 8192}
-----END EXAMPLE INPUT JSON FILE TO 02_generate_bbs_parameters.py-----

Naming the previous file "in_02.json", the first script should be called as follows for generating 2048 bit strong strong
primes:

./02_generate_bbs_parameters.py in_02.json in_03.json 2048

This creates the file "in_03.json" containing two strong strong primes "bbs_p" and "bbs_q" (allowing to define a
Blum-Blum-Shub PRNG) and a starting point "bbs_s" (the variables order may vary in the JSON file):

-----BEGIN EXAMPLE INPUT JSON FILE TO 03_generate_prime_field_using_bbs.py (in_03.json)-----
{"bbs_p": 31689017185864113346205769733661035265825273087926736902219296344044199994227678422507103152135239649038293481161666727303318930110019615079552911293894958002080015664673360841216296657150024954861893134652452163199040684571586525891582976778676751784303242205287065396944905908619931632380125653702000213663717535506172332753800028953307547824544169687474245960760203888096798059661414797964328999369933404761214568373063016240188389183431763881050180067083568769528823142899336022822030864190419987847057103931736171078973607610649828469992503561661677694047627068796321603970394042430107865186824743484374112211599, "bbs_q": 20436540323482468106048658668899830589643849846033876552878793038609349211259501174005754800222148926486143722590832163597638642142457009119451563687907605548181392350248663218232894243249336130125100977781433546344951877170631589687348460740880961332682310730659560486289342649175179918573539101369434701777245201559384525866152674461894925044448557802348570007088219290615557910754644471318330855195157252499557971213195018655320136936989128798834064452925269580844042983301465184997857192784016174476880926716045391884400558331564343442559567444727126773914112979925341680092098573119150602797487160257196077308567, "bbs_s": 249168140395072389461216418929952612543831193392902983437499645695265476060515061197626593793781010396190064755073085838530904109669581811851360499902732287656276635110692401062059927488786879793267452500989834123240708523073766297699968871656290629533600179158381282734247777243776930354887897944135929902452873763267113250046492455575998471398711027255639064385677446453493711656317659575505199044847111069314877320098230081240735789666746496016399242868479809751692595897674485678110417603961593799473148422681978890943339126017862289142891663203153902545898076889508316859111098491306915868620537609337968510121130318515444460190832009154213631221385476745126984869581686470061695322879512041111357738790325976822083301073400714424680094320102640029602649086850663764048761895565031277644852078111252078855764361354042446858061896674355322176958836055962900003556520856778879514174930336904713889559470597737404784478985033391463700718712521793627946823161435745796727753111272866250525610890563184860931348177003128554218506709150924298109020089156119522523272388800567885472834417182323675897769242296798034122928659758044908316234887097283541514026222659729099804033783444834852584780228575753428261459056746005418389049351859}
-----END EXAMPLE INPUT JSON FILE TO 03_generate_prime_field_using_bbs.py-----

The second script should be then called as follows to generate a 256 bit prime:

./03_generate_prime_field_using_bbs.py in_03.json in_04.json 256

This creates the file "in_04.json" containing the updated state of the Blum-Blum-Shub PRNG and the 256 bit prime that
defines the base field for the curve we will generate.

-----BEGIN EXAMPLE INPUT JSON FILE TO 04_generate_curve_using_bbs.py (in_04.json)-----
{"bbs_p": 31689017185864113346205769733661035265825273087926736902219296344044199994227678422507103152135239649038293481161666727303318930110019615079552911293894958002080015664673360841216296657150024954861893134652452163199040684571586525891582976778676751784303242205287065396944905908619931632380125653702000213663717535506172332753800028953307547824544169687474245960760203888096798059661414797964328999369933404761214568373063016240188389183431763881050180067083568769528823142899336022822030864190419987847057103931736171078973607610649828469992503561661677694047627068796321603970394042430107865186824743484374112211599, "bbs_q": 20436540323482468106048658668899830589643849846033876552878793038609349211259501174005754800222148926486143722590832163597638642142457009119451563687907605548181392350248663218232894243249336130125100977781433546344951877170631589687348460740880961332682310730659560486289342649175179918573539101369434701777245201559384525866152674461894925044448557802348570007088219290615557910754644471318330855195157252499557971213195018655320136936989128798834064452925269580844042983301465184997857192784016174476880926716045391884400558331564343442559567444727126773914112979925341680092098573119150602797487160257196077308567, "bbs_s": 322071963291663716917774551061565294686496186967057845843355808411218136251288652311896939969024251380176429018737879345529195391921767658988999217291232586420451985975786558490163556210746119918509981250951789828812782223999722262183372028011203721635684122998626302128362287217269676797455807038042622839599488495286919732196174325951293328419108522973531138865356852903107039879472820554421768245698991862757307957116091093784058953453134027912038578795575771134115692311866301818195773601568908586649574282899931639739034170233477992977063341200547563035035186811710870412922792878120996029250006604885041137418226877111046920439962367682934939103258248848180696799044371038251015032614448505740173010073451077317977727726512503194663924179032306819097418041159066163564146956993482218601366390463517895452491794277321319157188315091207180132132011630737246993377985544342649138795962791350189555959502385976204809089384228479158060479286034437758815366721949515406330256287547220288872625634288394065304069078184466732536682966990996471909395244619618368342196447839330685600724174451198115983068922672563397995985458194813638498712113952606416713503496110768161892458211060418115758809982465049710516708347382294330553793305249, "p": 64504250679033426621610668922272183107906922793895842420881345065223424734439}
-----END EXAMPLE INPUT JSON FILE TO 04_generate_curve_using_bbs.py-----

The last script takes the previous file as an input:

./04_generate_curve_using_bbs.py in_04.json out.json

This generates a file out.json containing the parameters of the cryptosystem:

-----BEGIN EXAMPLE FINAL OUTPUT FILE (out.json)-----
{"base_point_x": 12839792302829058863461642698901602398474369631382586733290514302942251646725, "base_point_y": 29296028195795808326226115613704019441291977477644854320846307553846085704021, "bbs_p": 31689017185864113346205769733661035265825273087926736902219296344044199994227678422507103152135239649038293481161666727303318930110019615079552911293894958002080015664673360841216296657150024954861893134652452163199040684571586525891582976778676751784303242205287065396944905908619931632380125653702000213663717535506172332753800028953307547824544169687474245960760203888096798059661414797964328999369933404761214568373063016240188389183431763881050180067083568769528823142899336022822030864190419987847057103931736171078973607610649828469992503561661677694047627068796321603970394042430107865186824743484374112211599, "bbs_q": 20436540323482468106048658668899830589643849846033876552878793038609349211259501174005754800222148926486143722590832163597638642142457009119451563687907605548181392350248663218232894243249336130125100977781433546344951877170631589687348460740880961332682310730659560486289342649175179918573539101369434701777245201559384525866152674461894925044448557802348570007088219290615557910754644471318330855195157252499557971213195018655320136936989128798834064452925269580844042983301465184997857192784016174476880926716045391884400558331564343442559567444727126773914112979925341680092098573119150602797487160257196077308567, "bbs_s": 252794523220794263781341019304727776594527433266943122230136031717979715789240082798491425658162758774349842337591220958578284977915160836107375097883296075804641455994490638948093190913214815191752392402940361764589127687789044177385265429574854672022744437578393646400623852901653193022804918507755015736059640389346454161380779619475805419956010226053724142254945291075564995033457124621381908797625193551704810848779071316054721797039910115304889227871776222215738425500932425102710480278864620316279290382144878494699605916114000833508036042055331769250451273418182388657625573223620259122307861883038854081299425608918817140920695652543769917319808076972976753587518314054178017591463304516511237544127112039360224975816254789816137336600332847567683960864205751370922039724688988756457559748738476936174452048123750623609315545517869781706429887729884749144730378231890892019823221432835136595282887444966992226232606689570898498617221310046038989944691055570156516365135606059796351968920742143953575963379423710663496913497066566379510700754926206263982607121704237021593962463200593958477691166366336261565210431554798840304930396376130674577853431127732935847125292643499219155233367283574092065748503476948307549057517459, "candidate_nbr": 269796, "cardinality": 64504250679033426621610668922272183108046543104817064754725418572258913779924, "cardinality_twist": 64504250679033426621610668922272183107767302482974620087037271558187935688956, "d": 42608320749334595579612426103580863030010031057139562106910811256056280235795, "discriminant": -2385231714943949099773260178858027889055569812629664061747411231355282781435, "embedding_degree": 16126062669758356655402667230568045777011635776204266188681354643064728444980, "embedding_degree_twist": 16126062669758356655402667230568045776941825620743655021759317889546983922238, "p": 64504250679033426621610668922272183107906922793895842420881345065223424734439, "trace": -139620310921222333844073507035489045484}
-----END EXAMPLE FINAL OUTPUT FILE (out.json)-----

# Source code of the 3 scripts

The 3 scripts were tested with the 3.4.3 version of Python [3]. They make use of standard libraries, as well as the
non-standard gmpy2 v.2.0.7 library. The underlying version of GMP [4] we used is the 6.1.0. The scripts also use 4
helpers (the source of which is also provided bellow):

- utils.py

- bbsengine.py

- subroutines.py

- pari_light_interface.py

The last helper is a simple interface to certain functionalities of the PARI library [2].

-----BEGIN 02_generate_bbs_parameters.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import argparse
import json
import os
import subroutines
import utils
import math
import gmpy2

def main():

    # Test local versions of libraries

    utils.test_python_version()
    utils.test_gmpy2_version()

    # Parse command line arguments
    
    parser = argparse.ArgumentParser(description="Generate BBS parameters.")
    
    parser.add_argument("input_file", help="""JSON file containing the seed used for generating the pseudo strong 
                                              strong prime (the name is "seed"). The required
                                              quantity of entropy it should contain depends on bitsize. As a rule of
                                              thumb the seed should contain at least 4*bitsize bits of entropy.""")
    parser.add_argument("output_file", help="""Output JSON file where this script will write the two generated strong
                                               strong primes "p" and "q". The output file should not exist already.""")
    parser.add_argument("min_prime_bitsize", type=int, help="minimum strong strong prime bit size (e.g. 2048).")
    
    args = parser.parse_args()

    
    # Check arguments
    
    output_file = args.output_file
    if os.path.exists(output_file):
        utils.exit_error("The output file '%s' already exists. Exiting."%(output_file))


    # Declare a few important variables
        
    min_prime_bitsize = args.min_prime_bitsize

    input_file = args.input_file
    with open(input_file, "r") as f:
        data = json.load(f)        
    seed = int(data["seed"])
    seed_upper_bound = int(data["seed_upper_bound"])
    approx_seed_entropy = math.floor(gmpy2.log2(seed_upper_bound))

    utils.colprint("Minimum strong strong prime size:", str(min_prime_bitsize))
    utils.colprint("Approximate seed entropy:", str(approx_seed_entropy))

    
    # Precomputations

    first_primes = [2]                     # List of the first primes
    PI = 2                                 # Product of the primes in "first_primes"
    strong_strong_integers = [[1]]         # strong_strong_integers[i] is the list of all strong strong integers modulo
                                           # first_primes[i]
    number_of_strong_strong_integers = [1] # number_of_strong_strong_integers[i] is the number of elements of the list
                                           # strong_strong_integers[i]
    C = 1                                  # Product of the elements of "number_of_strong_strong_integers"
    
    while not 2**(min_prime_bitsize-2) < PI:
        p = int(gmpy2.next_prime(first_primes[-1]))
        first_primes.append(p)
        PI *= p
        ssi = [c for c in range(p) if is_strong_strong_basis(c, p)]
        strong_strong_integers.append(ssi)
        number_of_strong_strong_integers.append(len(ssi))
        C *= len(ssi)

    utils.colprint("Number of primes considered:", str(len(first_primes)))
    utils.colprint("Number of strong strong integers to choose from:", "about 2^%f"%(gmpy2.log2(C)))

    
    # Check that the seed is long enough

    if seed_upper_bound < C**2 * (1 << (2 * min_prime_bitsize)):
        utils.exit_error("The seed does not contain the required entropy.")

        
    # Precomputations for the CRT

    mu    = [gmpy2.divexact(PI,p) for p in first_primes]
    delta = [gmpy2.invert(x,y) for x,y in zip(mu,first_primes)]
    gamma = [gmpy2.mul(x,y) for x,y in zip(mu,delta)]


    # Generate the first strong prime
    
    print("Generating the first strong strong prime...")
    (p,seed) = generate_strong_strong_prime(seed,
                                            min_prime_bitsize,
                                            strong_strong_integers,
                                            number_of_strong_strong_integers,
                                            gamma,
                                            PI)
    utils.colprint("\tThis is the first strong strong prime:", str(p))

    
    # Generate the second strong prime
    
    print("Generating the second strong strong prime...")
    (q,seed) = generate_strong_strong_prime(seed,
                                            min_prime_bitsize,
                                            strong_strong_integers,
                                            number_of_strong_strong_integers,
                                            gamma,
                                            PI)
    utils.colprint("\tThis is the second strong strong prime:", str(q))

    
    # Generate the BBS start

    print("Generating the BBS starting point...")    
    n = p*q
    s = seed % n
    while s == 0 or s == 1 or s == p or s == q:
        s = (s+1) % n
    s0 = (s**2) % n
    utils.colprint("\tThis is the starting point s0 of BBS:", str(s0))

    
    # Save p,q, and s to the output_file

    print("Saving p,q, and s0 to %s"%(output_file))
    with open(output_file, "w") as f:
        json.dump({"bbs_p": int(p), 
                   "bbs_q": int(q), 
                   "bbs_s": int(s0)}, 
                  f,
                  sort_keys=True)


    
def generate_strong_strong_prime(seed, min_bitsize,strong_strong_integers,number_of_strong_strong_integers,gamma,PI):
    """Return a strong strong prime deterministically determined from the input parameters, and what remains of the seed.

    Depending on the target prime size "min_bitsize", we need to find the appropriate table of first primes
    [p_0,...,p_{f-2},p_{f-1}] such that PI = p_0 * ... * p_{f-1} is larger than 2**(min_bitsize-2), but such that p_0 *
    ... * p_{f-2} is not. We'll store the primes in a table called "first_primes", such that first_primes[i] = p_i. The
    variable "strong_strong_integers" will be a list of lists, such that strong_strong_integers[i] is the list of
    integers r such that r, 2r+1 and 2(2r+1)+1 are invertible modulo first_primes[i]. Taking the inverse CRT on any
    
    [c_0,c_1,...,c_{f-1}] = [strong_strong_integers[0][i],strong_strong_integers[1][j],...,strong_strong_integers[f-1][k]]

    gives an integer c such that c, 2c+1, and 4c+3 are invertible modulo PI, which makes c a good candidate for being
    a strong strong prime generator (i.e., 4c+3 a good candidate for being a strong strong prime). The seed allows to
    determine in initial array [c_0,c_1,...,c_{f-1}] and thus an initial candidate c. Going from one such array to the
    other is done deterministically.

    """

    # Consume the seed and update it
    
    (indexes, seed) = list_of_indexes_from_seed(seed, number_of_strong_strong_integers)
    
    candidate_nbr = 0
    while True:

        alpha = [x[i] for x, i in zip(strong_strong_integers, indexes)] # alpha is in Z2* x Z3* x Z5* x ..... Apply the inverse CRT
        c = sum([x*y for x, y in zip(alpha, gamma)]) % PI
        candidate_nbr += 1
        
        if gmpy2.bit_length(c) >= min_bitsize-2 and subroutines.is_strong_strong_prime_generator(c):
            break

        indexes = next_indexes(indexes, number_of_strong_strong_integers)

    print("\tThe successful candidate is the number %d"%(candidate_nbr))

    return (4*c + 3,seed)

    

def is_strong_strong_basis(alpha, p):
    """Return True if alpha, 2*alpha+1, and 2*(2*alpha+1) + 1 are invertible modulo p,
    and false otherwise.

    """

    if (alpha % p) == 0:
        return False
    if ((2*alpha + 1) % p) == 0:
        return False
    if ((2*(2*alpha + 1) + 1) % p) == 0:
        return False
    return True


def list_of_indexes_from_seed(seed, max_indexes):
    """Return a list of len(max_indexes) indexes computed from the seed, such that
    0 <= indexes[i] < max_indexes[i]. Also return what remains from the seed.
    """
    indexes = []
    for i in range(len(max_indexes)):
        r = seed % max_indexes[i]
        seed = (seed-r) // max_indexes[i]
        indexes.append(r)
    return (indexes,seed)


def next_indexes(indexes, max_indexes):
    i = 0
    while True:
        indexes[i] = (indexes[i]+1) % max_indexes[i]
        if indexes[i] == 0:
            i = (i+1) % len(indexes)
        else:
            break
    return indexes

    
if __name__ == "__main__":
    main()
-----END 02_generate_bbs_parameters.py-----

-----BEGIN 03_generate_prime_field_using_bbs.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import argparse
import bbsengine
import json
import os
import subroutines
import utils
import gmpy2

def main():

    # Test local versions of libraries

    utils.test_python_version()
    utils.test_gmpy2_version()
    
    # Parse command line arguments

    parser = argparse.ArgumentParser(description="Generate a prime field, suited for being the underlying field of a twist-secure Edwards curve.")
    parser.add_argument("input_file", help="JSON file containing the BBS parameters (typically, the output of 02_generate_bbs_parameters.py).")
    parser.add_argument("output_file", help="Output file where this script will write the prime of the field and the current BBS parameters.")
    parser.add_argument("prime_size", type=int, help="Size of the prime (e.g. 256 bits)")
    
    args = parser.parse_args()

    
    # Check arguments

    output_file = args.output_file
    if os.path.exists(output_file):
        utils.exit_error("The output file '%s' already exists. Exiting."%(output_file))

    size = int(args.prime_size)

    input_file = args.input_file
    with open(input_file, "r") as f:
        data = json.load(f)        
    bbs_p = int(data["bbs_p"])
    bbs_q = int(data["bbs_q"])
    bbs_n = bbs_p * bbs_q
    bbs_s = int(data["bbs_s"]) % bbs_n

    
    # Check inputs

    print("Checking inputs...")
    if not subroutines.is_strong_strong_prime(bbs_p):
        utils.exit_error("bbs_p is not a strong strong prime.")
    if not subroutines.is_strong_strong_prime(bbs_q):
        utils.exit_error("bbs_q is not a strong strong prime.")

        
    # Initialize BBS

    bbs = bbsengine.BBS(bbs_p, bbs_q, bbs_s)

    
    # generate a "size"-bit prime "p"

    candidate_nbr = 0
    print("Generating a prime field Fp (where p is congruent to 3 mod 4)...")
    while True:
        candidate_nbr += 1
        bits = [1] + bbs.genbits(size-3) + [1,1]
        assert(len(bits) == size)
        p = 0
        for bit in bits:
            p = (p << 1) | bit
        assert(p % 4 == 3)
        assert(gmpy2.bit_length(p) == size)
        if subroutines.deterministic_is_pseudo_prime(p):
            break
    utils.colprint("%d-bit prime found:"%size, str(p))
    utils.colprint("The good candidate was number: ", str(candidate_nbr))

    
    # Save p and the current bbs parameters to the output_file

    print("Saving p and the BBS parameters to %s"%(output_file))
    bbs_s = bbs.s
    with open(output_file, "w") as f:
        json.dump({"p": int(p), 
                   "bbs_p": int(bbs_p), 
                   "bbs_q": int(bbs_q), 
                   "bbs_s": int(bbs_s)}, 
                  f,
                  sort_keys=True)

    
if __name__ == "__main__":
    main()
-----END 03_generate_prime_field_using_bbs.py-----

-----BEGIN 04_generate_curve_using_bbs.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import argparse
import bbsengine
import json
import os
import utils
import subroutines
from datetime import datetime
import sys
import gmpy2

def main():

    # Test local versions of libraries

    utils.test_python_version()
    utils.test_gmpy2_version()
    utils.test_pari_version()
    utils.test_pari_seadata()
    
    now = datetime.now()
    
    # Parse command line arguments

    parser = argparse.ArgumentParser(description="Generate an Edwards curve over a given prime field, suited for cryptographic purposes.")
    parser.add_argument("input_file",
                        help="""JSON file containing the BBS parameters and the prime of the underlying field (typically, the output of
                        03_generate_prime_field_using_bbs.py.
                        """)
    parser.add_argument("output_file", help="Output file where this script will write the parameter d of the curve and the current BBS parameters.")
    parser.add_argument("--start",
                        type=int,
                        help="Number of the candidate to start with (default is 1).",
                        default=1)
    parser.add_argument("--max_nbr_of_tests",
                        type=int,
                        help="Number of candidates to test before stopping the script (default is to continue until success).")
    parser.add_argument("--fast",
                        help=""" While computing a the curve cardinality with SAE, early exit when the cardinality will obviously be divisible by
                        a small integer > 4. This reduces the time required to find the final curve, but the
                        cardinalities of previous candidates are not fully computed.
                        """,
                        default=False,
                        action="store_true")

    args = parser.parse_args()

    
    # Check arguments

    print("Checking inputs...")
    
    output_file = args.output_file
    if os.path.exists(output_file):
        utils.exit_error("The output file '%s' already exists. Exiting."%(output_file))

    input_file = args.input_file
    with open(input_file, "r") as f:
        data = json.load(f)

        
    # Declare a few important variables
        
    bbs_p = int(data["bbs_p"])
    bbs_q = int(data["bbs_q"])
    bbs_n = bbs_p * bbs_q
    bbs_s = int(data["bbs_s"]) % bbs_n
    p = int(data["p"])

    start = max(int(args.start),1)

    max_nbr_of_tests = None
    if args.max_nbr_of_tests:
        max_nbr_of_tests = int(args.max_nbr_of_tests)
        
    if not subroutines.is_strong_strong_prime(bbs_p):
        utils.exit_error("bbs_p is not a strong strong prime.")
    if not subroutines.is_strong_strong_prime(bbs_q):
        utils.exit_error("bbs_q is not a strong strong prime.")
    if not (subroutines.deterministic_is_pseudo_prime(p) and p%4 == 3):
        utils.exit_error("p is not a prime congruent to 3 modulo 4.")

        
    # Initialize BBS

    print("Initializing BBS...")
    bbs = bbsengine.BBS(bbs_p, bbs_q, bbs_s)

    
    # Info about the prime field
    
    utils.colprint("Prime of the underlying prime field:", "%d (size: %d)"%(p, gmpy2.bit_length(p)))    
    size = gmpy2.bit_length(p) # total number of bits queried to bbs for each test

    
    # Skip the first "start" candidates
    
    candidate_nbr = start-1
    bbs.skipbits(size * (start-1))


    # Start looking for "d"
    
    while True:
        
        if max_nbr_of_tests and candidate_nbr >= start + max_nbr_of_tests - 1:
            print("Did not find an adequate parameter, starting at candidate %d (included), limiting to %d candidates."%(start, max_nbr_of_tests))
            utils.exit_error("Last candidate checked was number %d."%(candidate_nbr))

        candidate_nbr += 1

        bits = bbs.genbits(size)
        d = 0
        for bit in bits:
            d = (d << 1) | bit
        print("The candidate number %d is d = %d (ellapsed time: %s)"%(candidate_nbr, d, str(datetime.now()-now)))

        
        # Test 1
        
        if not utils.check(d != 0 and d < p, "d != 0 and d < p", 1):
            continue

        # Test 2
        
        if not utils.check(gmpy2.legendre(d, p) == -1, "d is not a square modulo p", 2):
            continue
        
        # Test 3
        
        if args.fast:
            cardinality = subroutines.sea_edwards(1, d, p, 4)
        else:
            cardinality = subroutines.sea_edwards(1, d, p)
        assert(cardinality % 4 == 0)
        q = cardinality>>2
        if not utils.check(subroutines.deterministic_is_pseudo_prime(q), "The curve cardinality / 4 is prime", 3):
            continue

        # Test 4
        
        trace = p+1-cardinality
        cardinality_twist = p+1+trace
        assert(cardinality_twist % 4 == 0)
        q_twist = cardinality_twist>>2
        if not utils.check(subroutines.deterministic_is_pseudo_prime(q_twist), "The twist cardinality / 4 is prime", 4):
            continue
        
        # Test 5

        if not utils.check(q != p and q_twist != p, "Curve and twist are safe against additive transfer", 5):
            continue
        
        # Test 6

        embedding_degree = subroutines.embedding_degree(p, q)
        if not utils.check(embedding_degree > (q-1) // 100, "Curve is safe against multiplicative transfer", 6):
            continue

        # Test 7

        embedding_degree_twist = subroutines.embedding_degree(p, q_twist)
        if not utils.check(embedding_degree_twist > (q_twist-1) // 100, "Twist is safe against multiplicative transfer", 7):
            continue

        # Test 8

        D = subroutines.cm_field_discriminant(p, trace)
        if not utils.check(abs(D) >= 2**100, "Absolute value of the discriminant is larger than 2^100", 8):
            continue

        break

    
    # Find a base point

    while True:
    
        bits = bbs.genbits(size)
        y = 0
        for bit in bits:
            y = (y<<1) | bit
        u = int((1 - y**2) * gmpy2.invert(1 - d*y**2, p)) % p
        if gmpy2.legendre(u, p) == -1:
            continue
        x = gmpy2.powmod(u, (p+1) // 4, p)
        (x,y) = subroutines.add_on_edwards(x, y, x, y, d, p)
        (x,y) = subroutines.add_on_edwards(x, y, x, y, d, p)
        if (x, y) == (0, 1):
            continue

        assert((x**2 + y**2) % p == (1 + d*x**2*y**2) % p)
        
        break

    
    # Print some informations
    
    utils.colprint("Number of the successful candidate:", str(candidate_nbr))
    utils.colprint("Edwards elliptic curve parameter d is:", str(d))
    utils.colprint("Number of points:", str(cardinality))
    utils.colprint("Number of points on the twist:", str(cardinality_twist))
    utils.colprint("Embedding degree of the curve:", "%d"%embedding_degree)
    utils.colprint("Embedding degree of the twist:", "%d"%embedding_degree_twist)
    utils.colprint("Discriminant:", "%d"%D)
    utils.colprint("Trace:", "%d"%trace)
    utils.colprint("Base point coordinates:", "(%d, %d)"%(x, y))

    
    # Save p, d, x, y, etc. to the output_file

    print("Saving the parameters to %s"%output_file)
    bbs_s = bbs.s
    with open(output_file, "w") as f:
        json.dump({"p": int(p),
                   "bbs_p": int(bbs_p),
                   "bbs_q": int(bbs_q),
                   "bbs_s": int(bbs_s),
                   "candidate_nbr": int(candidate_nbr),
                   "d": int(d),
                   "cardinality": cardinality,
                   "cardinality_twist": cardinality_twist,
                   "embedding_degree": embedding_degree,
                   "embedding_degree_twist": embedding_degree_twist,
                   "discriminant": D,
                   "trace": trace,
                   "base_point_x": x,
                   "base_point_y": y},
                  f,
                  sort_keys=True)

    
if __name__ == "__main__":
    main()
-----END 04_generate_curve_using_bbs.py-----

-----BEGIN bbsengine.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import gmpy2

class BBS:
    """Blum Blum Shub Pseudo Random Generator Engine"""

    def __init__(self, p, q, s, shift=0):
        self.p = p
        self.q = q            
        self.n = p * q
        power = (2**shift) % ((p-1) * (q-1))
        self.s = s % self.n
        self.s = gmpy2.powmod(self.s, power, self.n)

    def genbit(self):
        self.s = (self.s**2) % self.n
        return self.s & 1

    def genbits(self, k):
        bits = []
        for i in range(k):
            bits.append(self.genbit())
        return bits

    def skipbits(self,k):
        power = (2**k) % ((self.p-1) * (self.q-1))
        self.s = gmpy2.powmod(self.s, power, self.n)
-----END bbsengine.py-----

-----BEGIN pari_light_interface.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import os
import ctypes
import ctypes.util

libpari = ctypes.CDLL(ctypes.util.find_library("pari"))


_fx_pari_version          = libpari.pari_version
_fx_pari_version.argtypes = None
_fx_pari_version.restype  = ctypes.c_void_p

def pari_version():
    return _fx_pari_version()


_fx_pari_sd_datadir          = libpari.sd_datadir
_fx_pari_sd_datadir.argtypes = [ctypes.c_char_p, ctypes.c_long]
_fx_pari_sd_datadir.restype  = ctypes.c_void_p

def pari_sd_datadir():
    return _fx_pari_sd_datadir(None, 3) # Deduced from paridecl.h


_fx_pari_init          = libpari.pari_init
_fx_pari_init.argtypes = [ctypes.c_size_t, ctypes.c_ulong]
_fx_pari_init.restype  = None

def pari_init(size, maxprime):
    _fx_pari_init(size, maxprime)


_fx_pari_close          = libpari.pari_close
_fx_pari_close.argtypes = None
_fx_pari_close.restype  = None

def pari_close():
    _fx_pari_close()
    

_fx_pari_gp_read_str          = libpari.gp_read_str
_fx_pari_gp_read_str.argtypes = [ctypes.c_char_p]
_fx_pari_gp_read_str.restype  = ctypes.c_void_p

def pari_gp_read_str(s):
    return _fx_pari_gp_read_str(str(s).encode("UTF-8"))


_fx_pari_GENtostr          = libpari.GENtostr
_fx_pari_GENtostr.argtypes = [ctypes.c_void_p]
_fx_pari_GENtostr.restype  = ctypes.c_char_p

def pari_GENtostr(a):
    return _fx_pari_GENtostr(a)


_fx_pari_addii          = libpari.addii
_fx_pari_addii.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_fx_pari_addii.restype  = ctypes.c_void_p

def pari_addii(a, b):
    return _fx_pari_addii(a, b)


_fx_pari_Fp_ellcard_SEA          = libpari.Fp_ellcard_SEA
_fx_pari_Fp_ellcard_SEA.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_long]
_fx_pari_Fp_ellcard_SEA.restype  = ctypes.c_void_p

def pari_Fp_ellcard_SEA(a4, a6, p, s):
    return _fx_pari_Fp_ellcard_SEA(a4, a6, p, s)


_fx_pari_Z_factor          = libpari.Z_factor
_fx_pari_Z_factor.argtypes = [ctypes.c_void_p]
_fx_pari_Z_factor.restype  = ctypes.c_void_p

def pari_Z_factor(n):
    return _fx_pari_Z_factor(n)


def pari_gel(x, i):
    s = ctypes.sizeof(ctypes.c_void_p)
    v = ctypes.c_void_p.from_address(x + i*s)
    return v.value


def pari_lg(z):
    s = ctypes.sizeof(ctypes.c_void_p)
    header = ctypes.c_long.from_address(z).value
    mask = (1 << (8*s - 8)) - 1 # Deduced from parigen.h
    return header & mask
-----END pari_light_interface.py-----

-----BEGIN subroutines.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import pari_light_interface
import gmpy2

FIRST_PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,
                103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
                223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,
                347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
                463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
                607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
                743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881,
                883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,
                1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129,
                1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277,
                1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,
                1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,
                1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619]

def pari_version():

    pari_light_interface.pari_init(100000000, 0)

    _v = pari_light_interface.pari_version()
    _x = pari_light_interface.pari_gel(_v, 1)
    _y = pari_light_interface.pari_gel(_v, 2)
    _z = pari_light_interface.pari_gel(_v, 3)
    x = int(pari_light_interface.pari_GENtostr(_x))
    y = int(pari_light_interface.pari_GENtostr(_y))
    z = int(pari_light_interface.pari_GENtostr(_z))

    pari_light_interface.pari_close()
    
    return str("%d.%d.%d"%(x,y,z))

def pari_cfg_datadir():

    pari_light_interface.pari_init(100000000, 0)

    _s = pari_light_interface.pari_sd_datadir()
    s = str(pari_light_interface.pari_GENtostr(_s).decode('utf-8'))[1:-1]
    
    pari_light_interface.pari_close()

    return s
    
def sea_weierstrass(a, b, p, s=0):

    pari_light_interface.pari_init(100000000, 0)

    _a = pari_light_interface.pari_gp_read_str(str(a))
    _b = pari_light_interface.pari_gp_read_str(str(b))
    _p = pari_light_interface.pari_gp_read_str(str(p))

    _t = pari_light_interface.pari_Fp_ellcard_SEA(_a, _b, _p, s)
    t  = pari_light_interface.pari_GENtostr(_t)
    
    pari_light_interface.pari_close()
    
    return int(t)

def sea_montgomery(A, B, p, s=0):
    (a,b) = _weierstrass_parameters_from_montgomery_parameters(A, B, p)
    return sea_weierstrass(a, b, p, s)

def sea_edwards(a, d, p, s=0):
    (A,B) = _montgomery_parameters_from_edwards_parameters(a, d, p)
    return sea_montgomery(A, B, p, s)

def _weierstrass_parameters_from_montgomery_parameters(A, B, p):
    a = ((3 - A**2) * gmpy2.invert(3*B**2, p)) % p
    b = ((2*A**3 - 9*A) * gmpy2.invert(27*B**3, p)) % p
    return (a, b)

def _montgomery_parameters_from_edwards_parameters(a, d, p):
    A = (2 * (a+d) * gmpy2.invert(a - d, p)) % p
    B = (4 * gmpy2.invert(a - d, p)) % p
    return (A, B)

def factor(n):

    pari_light_interface.pari_init(100000000, 0)

    _n = pari_light_interface.pari_gp_read_str(str(n))

    _A = pari_light_interface.pari_Z_factor(_n)
    _P = pari_light_interface.pari_gel(_A, 1)
    _M = pari_light_interface.pari_gel(_A, 2)
    l = pari_light_interface.pari_lg(_P)
    
    f = []
    for i in range(1, l):
        _p = int(pari_light_interface.pari_gel(_P, i))
        p = int(pari_light_interface.pari_GENtostr(_p))
        _m = int(pari_light_interface.pari_gel(_M, i))
        m = int(pari_light_interface.pari_GENtostr(_m))
        if f and len(f) > 0:
            assert(p > f[-1][0]) # if this fails, add some code that makes sure f is sorted
        f.append([p, m])

    pari_light_interface.pari_close()
    
    return f

def cm_field_discriminant(p, t):

    # Compute s^2, the largest square dividing t^2-4p
    s_square = 1
    factors = factor(t**2 - 4*p)
    for f in factors:
        if f[1] % 2 == 0:
            s_square *= f[0]**f[1]
        else:
            s_square *= f[0]**(f[1]-1)
    assert((t**2 - 4*p) % s_square == 0)

    # Compute D
    D = (t**2 - 4*p) // s_square
    if D % 4 != 1:
        D *= 4

    return D

def embedding_degree(p, q):
    """Given p (typically the prime of the base field) and q (typically the order of a large subgroup the EC), return the
    embedding degree of the curve, i.e., the smallest m such that p^m = 1 (mod q).
    
    Keyword arguments:
    p -- prime of the base field
    q -- the order of a large subgroup the EC
    """
    m = q - 1
    factors = factor(m)
    for f in factors:
        for i in range(f[1]):
            if (p^(m // f[0])) % q == 1:
                m = m // f[0]

    return m


def is_strong_prime(p):
    if not deterministic_is_pseudo_prime(p):
        return False
    p = (p-1) >> 1
    return deterministic_is_pseudo_prime(p)


def is_strong_strong_prime(p):
    if not deterministic_is_pseudo_prime(p):
        return False
    p = (p-1) >> 1
    if not deterministic_is_pseudo_prime(p):
        return False
    p = (p-1) >> 1
    return deterministic_is_pseudo_prime(p)


def is_strong_strong_prime_generator(p):
    if not deterministic_is_pseudo_prime(p):
        return False
    p = (p<<1) + 1
    if not deterministic_is_pseudo_prime(p):
        return False
    p = (p<<1) + 1
    return deterministic_is_pseudo_prime(p)

def add_on_edwards(x1, y1, x2, y2, d, p):
    x = int((x1*y2 + x2*y1) * gmpy2.invert(1+d*x1*x2*y1*y2, p)) % p
    y = int((y1*y2 - x1*x2) * gmpy2.invert(1-d*x1*x2*y1*y2, p)) % p
    return (x,y)

def deterministic_is_pseudo_prime(n, k=64):
    assert(k <= len(FIRST_PRIMES))
    if n in FIRST_PRIMES:
        return True
    if n < max(FIRST_PRIMES):
        return False
    if n & 1 == 0:
        return False
    # Find s and t
    s = 0
    t = n - 1
    while t & 1 == 0:
        s += 1
        t = t >> 1
    assert(n == 2**s * t + 1)
    # main loop
    for j in range(k):
        b = FIRST_PRIMES[j]
        x = gmpy2.powmod(b, t, n)
        i = 0
        if x != 1:
            while x != n - 1:
                x = gmpy2.powmod(x, 2, n)
                i += 1
                if i == s or x == 1:
                    return False
    return True
-----END subroutines.py-----

-----BEGIN utils.py-----
#!/usr/bin/env python3

# This file is part of Million Dollar Curve

# Copyright (C) 2015, 2016  CryptoExperts

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import sys
import platform
import os.path
import subroutines
import gmpy2


def exit_error(s):
    sys.exit("[ERROR] %s"%s)

    
def colprint(col1,col2 = "",col1_size = 50):
    col1_size = max(col1_size, len(col1))
    if col2 != "":
        print(col1 + " " * (col1_size - len(col1)) + col2)
    else:
        print(col1)

        
def check(test, test_description="", test_number=None):
    
    if test_description != "":
        if test_number != None:
            print("\tTest %d: %s... "%(test_number,test_description), end="", flush=True)
        else:
            print("\tTesting %s... "%(test_description), end="", flush=True)
            
    if test:
        print("Success")
        return True
    else:
        print("Failure")
        return False
    
    
def test_gmpy2_version():
    expected_gmpy2_version = '2.0.7'
    local_gmpy2_version = gmpy2.version()
    if local_gmpy2_version != expected_gmpy2_version:
        print('[WARNING] You are using version %s of gmpy2. These scripts have been tested with version %s'
              %(local_gmpy2_version, expected_gmpy2_version), file=sys.stderr)

        
def test_python_version():
    expected_python_version = '3.4.3'
    local_python_version = platform.python_version()
    if local_python_version != expected_python_version:
        print('[WARNING] You are using version %s of Python. These scripts have been tested with version %s'
              %(local_python_version, expected_python_version), file=sys.stderr)

        
def test_pari_version():
    expected_pari_version = '2.7.4'
    local_pari_version = subroutines.pari_version()
    if local_pari_version != expected_pari_version:
        print('[WARNING] You are using version %s of PARI. These scripts have been tested with version %s'
              %(local_pari_version, expected_pari_version), file=sys.stderr)
    
        
def test_pari_seadata():
    """Look for the seadata package for PARI. Exit if it cannot be found."""
    datadir = subroutines.pari_cfg_datadir()
    seadata_path = os.path.join(datadir,"seadata")
    if not os.path.exists(seadata_path):
        exit_error("Cannot find the seadata.tgz package for PARI. Please install this package in %s. See http://pari.math.u-bordeaux.fr/packages.html."%(datadir))
-----END utils.py-----

# References

[1] Thomas Baigneres, Cecile Delerablee, Matthieu Finiasz, and Tancrede Lepoint, With Little Help from our Friends. Trap Me If You Can. Available on https://www.cryptoexperts.com
[2] PARI/GP. http://pari.math.u-bordeaux.fr
[3] Python. https://www.python.org
[4] GMP. The GNU Multiple Precision Arithmetic Library. https://gmplib.org
